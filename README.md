# If-templates-look-confusing
Readme how to clarify this
### Для всех, кому непривычно (включая автора), но с излишним разжовыванием.

По мотивам видеодоклада https://www.youtube.com/watch?v=MvoBtGuYnk4  
Момент на видео: 01:11:20  
Мы хотим показать, что данная запутанность мнимая, и что это элементарности шаблонного метапрограммирования. Разберем операцию сложения на
примере чисел 7 и 4, и покажем последовательный вывод следующих шаблонных определений:

```cpp
template <typename S, typename T>
struct add: typename succ<typename add<S, typename T::pred>::type>::type {};
template <typename S>
struct add<S, zero>: S::type {};
```

Все остальные определения (умножение, факториал) "выводятся" точно так же, и они в данной методике не описаны. Вот исходный код с проверкой
его правильности:

```cpp
namespace ns1 {
    struct zero {
        static constexpr int value = 0;
        using type = zero;
    };

    template <typename T>
    struct succ {
        static constexpr int value = 1 + T::value;
        using pred = typename T::type;
        using type = succ<typename T::type>;
    };

    template <typename S, typename T>
    struct add: succ<typename add<S, typename T::pred>::type>::type {};
    template <typename S>
    struct add<S, zero>: S::type {};

    using _0 = zero;
    using _4 = succ<succ<succ<succ<_0>>>>::type;
    using _7 = succ<succ<succ<_4>>> ::type;
    static_assert(_4::value == 4);
    static_assert(_7::value == 7);
    static_assert(add<_4, _7>::value == 11);
}
```

Для начала упростим рекурсивное определение _add<>_ , избавившись от мельтешащих перед глазами и мешающих ясности понимания слов **typename**
и **type**. Для этого нужно для шаблонных классов _succ<>_ и _add<>_ создать псевдонимы типов, и в новом определении использовать уже их.

```cpp
namespace ns2 {
    using namespace ns1;

    template <class T>
    using succ_t = typename succ<T>::type;
    template <class S, class T>
    using add_t = typename add<S, T>::type;
    template <class T>
    using pred_t = typename T::pred;

    template <typename S, typename T>
    struct add: succ_t<add_t<S, pred_t<T> > > {};

    static_assert(add<_4, _7>::value == 11);
}
```

Теперь запись _add_ выглядит гораздо более естественно. Выражение **typename T::pred** тоже удалось чуть упростить. Итак, начнем разбираться.
Напишем теперь runtime-версию функции сложения двух неотрицательных целых чисел. Ну, конечно же, она обязана быть рекурсивной!

```cpp
namespace ns3 {
    int add(int S, int T) {
        if (T)
            return add(S+1, T-1);
        else 
            return S; // T == 0
    }
}
int main() {
    std::cout << ns3::add(7,4) << '\n'; // выведет число 11
}
```

На каждом шаге рекурсии, мы декрементируем второй аргумент, но инкрементируем первый. Таким образом, S аккумулирует сумму за счет увеличения
одного значения и уменьшения другого. Когда рекурсия должна быть завершена (это называется базовый случай)? Когда второе значение обнулится.
А результат, накопленный в первом аргументе, мы должны вернуть вызывающей стороне. Таким образом, мы описали и рекурсивный и базовый случаи
данного элементарного алгоритма.  
Попробуем сделать функциональную декомпозицию, сохранив правильность вычисления суммы.

```cpp
namespace ns4 {
    int add(int S, int T) {
        if (T)
            return 1 + add(S, T-1);
        else
            return S; // T == 0
    }
}
int main() {
    std::cout << ns4::add(7,4) << '\n'; // выведет число 11
}
```

В данном случае мы не используем первый аргумент в качестве аккумулятора, а, декрементируя второй аргумент, компенсируем убыток каждый раз
добавляя его (убыток, в виде 1) к остальным постоянно накапливающимся единицам в ходе рекурсивных вызовов. Такая форма рекурсии, в отличие от
предыдущей, называется линейно-рекурсивной. Но почему мы снова возвращаем S в базовом случае? Уже по другой причине: в ходе рекурсивных
вызовов мы поединично накопили лишь значение второго аргумента (T). И в базовом случае должны вернуть это накопление сложенным со значением
первого аргумента (S).  

А вот сейчас можно заметить, что в рекурсивных случаях мы имеем просто инкрементацию значения выражения **add(S, T-1)** , и могли бы выразить
этот факт через отдельную функцию, на вход которой это значение каждый раз поступает. Поэтому, делаем еще одну, последнюю, функциональную
декомпозицию:

```cpp
namespace ns5 {
    int succ(int val) {
        return 1 + val;
    }
    int add(int S, int T) {
        if (T)
            return succ(add(S, T-1));
        else
            return S; // T == 0
    }
}
int main() {
    std::cout << ns5::add(7,4) << '\n'; // выведет число 11
}
```

Ну вот и ключ к разгадке! Сначала напишем (трафаретно) метапрограмму на шаблонных классах, принимающих аргументы-значения интегральных типов.
А потом (опять же, трафаретно) переведем ее на шаблоны классов, принимающих аргументы-классы.
Вот получившийся код с проверкой его правильности снова в compile-time:

```cpp
namespace ns6 {
    template <int val>
    struct succ {
        static constexpr int value = 1 + val;
    };
 
    template <int S, int T>
    struct add : succ<add<S, T-1>::value> {};

    template <int S>
    struct add<S, 0> { // Если Т == 0
        static constexpr int value = S;
    };
    
    static_assert(add<7,4>::value == 11);
}
```

Данная метапрограмма - почти полная копия последней нашей runtime-версии. В ней все сделано абсолютно единообразно. Единственный возможный
инвариант рекурсивного случая в ней: не наследоваться от шаблона _succ<>_ , а иметь его частью статической константы-члена шаблона _add<>_ :

```cpp
template <int S, int T>
struct add {
    static constexpr int value = succ<add<S, T-1>::value>::value;
};
```

Но эта запись выглядит длиннее, и других вариантов больше и нет.  
Окончательная версия на шаблонах классов, имеющих параметры типов классов и принимающих аргументы-классы, строится подобным же образом.

```cpp
namespace ns7 {
    template <class T>
    struct succ {
        static const int value = 1 + T::value;
        using pred = typename T::type;
        using type = succ<typename T::type>;
    };

    template <class S, class T>
    struct add : succ<typename add<S, typename T::pred>::type>::type { static_assert(T::pred::value == T::value - 1);};

    struct zero {
        static const int value = 0;
        using type = zero;
    };

    template <typename S>
    struct add<S, zero>: S::type {};

    using _0 = zero;
    using _4 = succ<succ<succ<succ<_0> > > >::type;
    using _7 = succ<succ<succ<_4> > > ::type;
    static_assert(add<_4, _7>::value == 11);
}
```

Мы пришли к той версии чужого кода, с которой и начинали, но написав при этом свой код. Интегральный тип *int* в параметрах шаблонов заменен
на классовые типы. А в тела шаблонных классов добавлены статические интегральные члены и члены-типы, используемые для тех же самых вычислений.
Единственное, для представления значения 0 для базового случая рекурсии, пришлось ввести отдельный нешаблонный класс _zero_ .  
Немного огорчает, что мы так и не избавились от выражения **typename T::pred** (или **pred_t** в случае псевдонима), не заменив его на
отдельный класс с названием, к примеру, _T_Minus_1_ . Но если чуть задуматься, в этом нет необходимости. Типы T (как и S), с которыми мы
работаем в рекурсивной ветке алгоритма _add<>_ , не могут быть ничем иным, кроме как _succ<>_ в той или иной рекурсивной инкарнации. Поэтому
из этого типа всегда можно извлечь предыдущее воплощение с прежним внутренним интегральным значением, что доказывает утверждение времени
компиляции:

```cpp
static_assert(T::pred::value == T::value - 1);
```
Примечание. Ну, конечно, написать в общем случае шаблон операции сложения на типах можно короче и прямо из первого runtime-варианта. Но речь в
видео идет о решении на основе "аксиоматики Пеано".
